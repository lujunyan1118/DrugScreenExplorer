areaTotal <- areaTotal + areaEach
}
aucRatio <- areaTotal/log(valueConc[nrow(valueConc),]$conc/valueConc[1,]$conc)
}
return(aucRatio)
}
#function to calculate AUC using linear-log trapezoidal method
calcAUC <- function(value, conc, viabCut=NULL) {
valueConc <- tibble(viab=value, conc=conc) %>%
filter(!is.na(conc) & conc > 0) %>% #remove zero concentration, not included in calculation of AUC.
group_by(conc) %>% summarise(viab = mean(viab)) %>%
ungroup() %>%  #make sure concentrations are unique
arrange(conc)
#censor the vlaues based on viability cut-off
if (!is.null(viabCut))
valueConc <- mutate(valueConc,viab = viab + 1-viabCut)) %>% mutate(viab=ifelse(viab >1,1,viab))
if (nrow(valueConc) %in% c(0,1)) {
return(mean(valueConc$viab, na.rm = TRUE))
} else {
areaTotal <- 0
for (i in seq(nrow(valueConc)-1)) {
areaEach <- (valueConc$viab[i] + valueConc$viab[i+1])*log(valueConc$conc[i+1]/valueConc$conc[i])*0.5
areaTotal <- areaTotal + areaEach
}
aucRatio <- areaTotal/log(valueConc[nrow(valueConc),]$conc/valueConc[1,]$conc)
return(aucRatio)
}
}
valueConc <- tibble(viab=value, conc=conc) %>%
filter(!is.na(conc) & conc > 0) %>% #remove zero concentration, not included in calculation of AUC.
group_by(conc) %>% summarise(viab = mean(viab)) %>%
ungroup() %>%  #make sure concentrations are unique
arrange(conc)
#censor the vlaues based on viability cut-off
if (!is.null(viabCut)) {
valueConc <- mutate(valueConc,viab = viab + 1-viabCut)) %>% mutate(viab=ifelse(viab >1,1,viab))
}
valueConc <- mutate(valueConc,viab = viab + 1-viabCut)) %>% mutate(viab=ifelse(viab >1,1,viab))
viabCut <- 0.9
valueConc <- mutate(valueConc,viab = viab + 1-viabCut)) %>% mutate(viab=ifelse(viab >1,1,viab))
calcAUC <- function(value, conc, viabCut=NULL) {
valueConc <- tibble(viab=value, conc=conc) %>%
filter(!is.na(conc) & conc > 0) %>% #remove zero concentration, not included in calculation of AUC.
group_by(conc) %>% summarise(viab = mean(viab)) %>%
ungroup() %>%  #make sure concentrations are unique
arrange(conc)
#censor the vlaues based on viability cut-off
if (!is.null(viabCut)) {
valueConc <- mutate(valueConc,viab = viab + 1-viabCut) %>% mutate(viab=ifelse(viab >1,1,viab))
}
if (nrow(valueConc) %in% c(0,1)) {
return(mean(valueConc$viab, na.rm = TRUE))
} else {
areaTotal <- 0
for (i in seq(nrow(valueConc)-1)) {
areaEach <- (valueConc$viab[i] + valueConc$viab[i+1])*log(valueConc$conc[i+1]/valueConc$conc[i])*0.5
areaTotal <- areaTotal + areaEach
}
aucRatio <- areaTotal/log(valueConc[nrow(valueConc),]$conc/valueConc[1,]$conc)
return(aucRatio)
}
}
valueConc <- tibble(viab=value, conc=conc) %>%
filter(!is.na(conc) & conc > 0) %>% #remove zero concentration, not included in calculation of AUC.
group_by(conc) %>% summarise(viab = mean(viab)) %>%
ungroup() %>%  #make sure concentrations are unique
arrange(conc)
ggplot(valueConc, aes(x=value, value = conc,)) + geom_line()
ggplot(valueConc, aes(x=value, h= conc,)) + geom_line()
ggplot(valueConc, aes(x=value, y= conc,)) + geom_line()
value
conc
value
value <c(1,0.9,0.7,0.3,0.1)
value <- c(1,0.9,0.7,0.3,0.1)
value
conc <- c(0, 0.1,0.01,0.001,0.0001)
value
conc
valueConc <- tibble(viab=value, conc=conc) %>%
filter(!is.na(conc) & conc > 0) %>% #remove zero concentration, not included in calculation of AUC.
group_by(conc) %>% summarise(viab = mean(viab)) %>%
ungroup() %>%  #make sure concentrations are unique
arrange(conc)
valueConc
ggplot(valueConc, aes(x=value, y= conc,)) + geom_line()
ggplot(valueConc, aes(x=value, y= conc)) + geom_line()
valueConc
ggplot(valueConc, aes(x=viab, y= conc)) + geom_line()
viab <- rev(viab)
value = rev(value)
valueConc <- tibble(viab=value, conc=conc) %>%
filter(!is.na(conc) & conc > 0) %>% #remove zero concentration, not included in calculation of AUC.
group_by(conc) %>% summarise(viab = mean(viab)) %>%
ungroup() %>%  #make sure concentrations are unique
arrange(conc)
valueConc
ggplot(valueConc, aes(x=value, y= conc)) + geom_line()
ggplot(valueConc, aes(x=viab, y= conc)) + geom_line()
valueConc <- muate(valueConc, newViab = viab+1-0.9)
valueConc <- mutate(valueConc, newViab = viab+1-0.9) %>% mutate(newViab = ifelse(newViab>1,1,newViab))
valueConc
plotTab <- gather(valueConc, key = "group", value = "val",-conc)
plotTab
ggplot(plotTab, aes(x=conc, y=val, group=group)) + geom_line()
ggplot(plotTab, aes(x=conc, y=val, group=group)) + geom_line(aes(type = group))
ggplot(plotTab, aes(x=conc, y=val, group=group)) + geom_line(aes(linetype = group))
ggplot(plotTab, aes(x=conc, y=val, group=group)) + geom_line(aes(linetype = group)) + scale_x_log10()
valueConc <- mutate(valueConc, newViab = viab+1-0.95) %>% mutate(newViab = ifelse(newViab>1,1,newViab))
plotTab <- gather(valueConc, key = "group", value = "val",-conc)
ggplot(plotTab, aes(x=conc, y=val, group=group)) + geom_line(aes(linetype = group)) + scale_x_log10()
newVi
newViab
plotTab
ggplot(plotTab, aes(x=conc, y=val, group=group)) + geom_line(aes(linetype = group)) + scale_x_log10() + geom_hline(yintercept = 0.95, color = "red")
calcAUC(value,conc)
value
conc
mean(value)
shiny::runApp('~/CLLproject_jlu/packages/DrugScreenExplorer/shiny')
stopifnot()
?stopifnot()
stopifnot(1>2)
stopifnot(1>2,"seriously")
setwd("~/CLLproject_jlu/packages/DrugScreenExplorer/R")
load("../shiny/shinyData.RData")
screenData
viabCol <- "normVal"
subData <- screenData[,c("sampleID","name","concentration",viabCol)]
subData
subData <- screenData[,c("sampleID","name","concentration","wellType",viabCol)]
subData
subData <- subData[subData$wellType %in% "sample",]
subData <- screenData[,c("sampleID","name","concentration","wellType",viabCol)]
subData <- subData[subData$wellType %in% "sample",]
colnames(subData) <- c("sampleID","name","concentration","wellType","viab")
subData
subData <- group_by(subData, sampleID, name, concentration) %>% summarise(viab = mean(viab))
subData
?left_join
sumTab <- group_by(subData, sampleID, name) %>% summarise(meanViab = mean(viab, na.rm=TRUE))
sumTab <- group_by(subData, sampleID, name) %>% summarise(meanViab = mean(viab, na.rm=TRUE))
screenData$meanViab <- sumTab[match(paste0(screenData$sampleID,"_",screenData$name),
paste0(sumTab$sampleID,"_",sumTab$name)),]$meanViab
screenData$sampleID
paste0(screenData$sampleID,"_",screenData$name)
sumTab <- group_by(subData, sampleID, name) %>% summarise(meanViab = mean(viab, na.rm=TRUE))
screenData$meanViab <- sumTab[match(paste0(screenData$sampleID,"_",screenData$name),
paste0(sumTab$sampleID,"_",sumTab$name)),]$meanViab
is.na(sumTab$sampleID)
!is.na(sumTab$sampleID)
all(!is.na(sumTab$sampleID))
all(!is.na(screenData$sampleID))
sumTab[match(paste0(screenData$sampleID,"_",screenData$name),
paste0(sumTab$sampleID,"_",sumTab$name)),]
sumTab[match(paste0(screenData$sampleID,"_",screenData$name),
paste0(sumTab$sampleID,"_",sumTab$name)),]$meanViab
screenData
screenData$normVal
sumTab <- group_by(subData, sampleID, name) %>% summarise(meanViab = mean(viab, na.rm=TRUE))
if ("meanViab" %in% colnames(screenData)) screenData[["meanViab"]] <- NULL
screenData <- left_join(screenData, sumTab, by= c("sampleID","name"))
screenData
subTab <- group_by(subData, sampleID, name) %>%
summarize(AUC = calcAUC(viab,concentration)) %>%
ungroup()
subTab
if ("AUC" %in% colnames(screenData)) screenData[["AUC"]] <- NULL
screenData <- left_join(screenData, sumTab, by = c("sampleID","name"))
screenData
screenData$meanViab.x <- NULL
screenData$meanViab.y <- NULL
screenData
subData <- group_by(subData, sampleID, name, concentration) %>%
summarise(viab = mean(normVal,na.rm = TRUE), viab.cor = mean(normVal.cor, na.rm=TRUE))
subData <- screenData[screenData$wellType %in% "sample",]
subData <- group_by(subData, sampleID, name, concentration) %>%
summarise(viab = mean(normVal,na.rm = TRUE), viab.cor = mean(normVal.cor, na.rm=TRUE))
subData
#only summarise for non-control wells
subData <- screenData[screenData$wellType %in% "sample",] %>%
group_by(subData, sampleID, name, concentration) %>%
summarise(viab = mean(normVal,na.rm = TRUE), viab.cor = mean(normVal.cor, na.rm=TRUE))
#only summarise for non-control wells
subData <- screenData[screenData$wellType %in% "sample",] %>%
group_by(sampleID, name, concentration) %>%
summarise(viab = mean(normVal,na.rm = TRUE), viab.cor = mean(normVal.cor, na.rm=TRUE))
subData
#' Model object for fitting the IC50 curve
#'
#' Use the drc package to perform IC50 fit. Can be directly used for geom_smooth() in ggplot2
#' @param formula Formula for the curve fitting.
#' @param data A data frame contain the raw concentration and the viability value. The viability should be the percent viability value.
#' @param weigths Not used, mainly for geom_smooth() purpose
#' @param ... Parameters passed to logLogisticRegression()
#' @export
#' @import drc
fitIC50 <- function(formula, data = NULL, weights, ...) {
if (! is.null(data) ) {
modelFrame <- model.frame(formula, data)
} else {
modelFrame <- model.frame(formula)
}
parm_fit <- drm(modelFrame, fct = LL2.3u(), ...)
newModel <- list(model = modelFrame, formula = formula, parm_fit = parm_fit)
class(newModel) <- "fitIC50"
return(newModel)
}
subTab <- group_by(subData, sampleID, name) %>%
summarize(AUC = fitIC50(viab ~ concentration,.))
library(drc)
subTab <- group_by(subData, sampleID, name) %>%
summarize(AUC = fitIC50(viab ~ concentration,.))
subTab <- group_by(subData, sampleID, name) %>%
nest() %>%
mutate(model = map(data, ~fitIC50(viab~concentration,.)))
head(subTab)
subTab[1,]$model
log(-4.0268)
exp(-4.0268)
plot(subTab[1,]$model)
class(subTab[1,]$model)
subTab[1,]$model$parm_fit
subTab[1,]$model
a <- subTab[1,]$model
a$parm_fit
a <- subTab[1,]$model
a
a[["parm_fit"]]
a
object.size()
testTab <- filter(subTab)
subTab
testTab <- filter(subData, sampleID == "11PB0010",name="Venetoclax")
testTab <- filter(subData, sampleID == "11PB0010",name=="Venetoclax")
testTab
a <- fitIC50(viab~concentration, testTab)
a
a$parm_fit
predict(a$parm_fit)
predict(a$parm_fit, seq(0,1,100))
predict(a$parm_fit, data.frame(concentration= seq(0,1,100)))
a$da
a$model
predict(a$parm_fit, newdata = data.frame(concentration= seq(0,1,100)))
newTab <- data.frame(concentration = seq(0,1,100))
newTab
newTab <- data.frame(concentration = seq(0,1,by = 0.01))
newTab
predict(a$parm_fit, newdata = data.frame(concentration= seq(0,1,by=0.01)))
plot(predict(a$parm_fit, newdata = data.frame(concentration= seq(0,1,by=0.01))))
integrate(a$parm_fit, lower = 0, upper = 1)
predict(a$parm_fit, newdata = 0.1)
predict(a$parm_fit, newdata = data.frame(concentration=0.1))
class(predict(a$parm_fit, newdata = data.frame(concentration=0.1)))
aa <- function(x) predict(a$parm_fit, newdata = data.frame(concentration=x))
aa
integrate(aa, 0, 1)
install.packages("dr4pl")
?dr4pl::dr4pl()
subTab
sumTab
aa
subTab[4,]$data
subTab[4,]$data[[1]]
aa <- subTab[4,]$data[[1]]
dr4pl::dr4pl(viab~concentration, aa)
plot(r4pl::dr4pl(viab~concentration, aa))
library(dr4pl)
plot(r4pl::dr4pl(viab~concentration, aa))
bb <- dr4pl::dr4pl(viab~concentration, aa)
bb
plot(bb)
bb <- dr4pl::dr4pl(viab~concentration, aa, init.parm = c(1,1,1,0))
plot(bb)
aa <- subTab[2,]$data[[1]]
bb <- dr4pl::dr4pl(viab~concentration, aa)
plot(bb)
bb
predict(aa)
predict(b)
predict(bb)
class(bb)
predY <- function(x) {
y = d + (a-d)/(1+(x/c)^b)
return(y)
}
d <- bb$parameters[1]
d
a <- d
d <- bb$parameters[4]
c <- bb$parameters[2]
b <- bb$parameters[3]
predY <- function(x) {
y = d + (a-d)/(1+(x/c)^b)
return(y)
}
predY(0.1)
predY(0.2)
x < 0.1
x<-0.1
d + (a-d)/(1+(x/c)^b)
d
a-d
class(d)
a
d
a-d
bb
predY(0.10)
predY(10)
predY(0)
a
d
qq <- a
a <- d
d <- qq
predY(0)
predY(100)
a
b
d
dr4pl()
?dr4pl()
#' Model object for fitting 4 parameter logistic (4PL) models
#'
#' Use the dr4pl package to perform a robust 4PL fit. Can be directly used for geom_smooth() in ggplot2
#' @param formula Formula for the curve fitting.
#' @param data A data frame contain the raw concentration and the viability value. The viability should be the percent viability value.
#' @param weigths Not used, mainly for geom_smooth() purpose
#' @param ... Parameters passed to logLogisticRegression()
#' @export
#' @import dr4pl
fitIC50 <- function(formula, data = NULL, weights, ...) {
if (! is.null(data) ) {
modelFrame <- model.frame(formula, data)
} else {
modelFrame <- model.frame(formula)
}
parm_fit <- dr4pl(modelFrame, ...)
newModel <- list(model = modelFrame, formula = formula, parm_fit = parm_fit)
class(newModel) <- "fitIC50"
return(newModel)
}
aa
fitIC50(viab~concentration, aa)
fitIC50(viab~concentration, data = aa)
?model.frame
model.frame(viab~concentration, aa)
modelFrame <- model.frame(viab~concentration, aa)
#' Model object for fitting 4 parameter logistic (4PL) models
#'
#' Use the dr4pl package to perform a robust 4PL fit. Can be directly used for geom_smooth() in ggplot2
#' @param formula Formula for the curve fitting.
#' @param data A data frame contain the raw concentration and the viability value. The viability should be the percent viability value.
#' @param weigths Not used, mainly for geom_smooth() purpose
#' @param ... Parameters passed to logLogisticRegression()
#' @export
#' @import dr4pl
fitIC50 <- function(formula, data = NULL, weights, ...) {
if (! is.null(data) ) {
modelFrame <- model.frame(formula, data)
} else {
modelFrame <- model.frame(formula)
}
parm_fit <- dr4pl(formula, data, ...)
newModel <- list(model = modelFrame, formula = formula, parm_fit = parm_fit)
class(newModel) <- "fitIC50"
return(newModel)
}
fitIC50(viab~concentration, data = aa)
fitIC50(viab~concentration, data = aa)
newModel <- fitIC50(viab~concentration, data = aa)
newModel$model
newModel$formula
newModel$parm_fit
newModel$parm_fit$parameters
params <- object$parm_fit$parameters
a <- parms[1]
object <- newModel
params <- object$parm_fit$parameters
a <- parms[1]
d <- parms[4]
x <- parms[2]
params <- object$parm_fit$parameters
a <- params[1]
d <- params[4]
x <- params[2]
b <- params[3]
a
d
object$formula
class(object$formula)
object$formula
object$formula[1]
object$formula[2]
object$formula[3]
as.character(object$formula)
terms(object$formula)
a <- params[1]
d <- params[4]
x <- params[2]
b <- params[3]
predY <- function(x) {
y = d + (a-d)/(1+(x/c)^b)
return(y)
}
predY(0)
predY(1)
predY(10)
a
b
d
params <- object$parm_fit$parameters
a <- min(params[1],params[4])
d <- max(params[4],params[1])
x <- params[2]
b <- params[3]
predY <- function(x) {
y = d + (a-d)/(1+(x/c)^b)
return(y)
}
a
predY(0)
predY(1)
params <- object$parm_fit$parameters
a <- min(params[1],params[4])
d <- max(params[4],params[1])
x <- params[2]
b <- params[3]
predY <- function(x) {
y = d + (a-d)/(1+(x/c)^b)
names(y) <- NULL
return(y)
}
predY
predY(10)
predY(1)
newdata <- c(1,2,3,4,5)
is.vector(newdata)
concName <- as.character(object$formula)[3]
concName
newdata
newdata <- object$model
concName <- as.character(object$formula)[3]
conc <- newdata[,concName]
conc
res <- sapply(conc, predY)
res
plot(res)
plot(res)
plot(bb)
#' Predicted values based on IC50 fit
#'
#' Generic function for ic50 class generated from fitIC50 function.
#' @param object Object of class inheriting from "fitIC50"
#' @param newdata An optional data frame in which to look for variables with which to predict.If omitted, the fitted values are used.
#' @param se.fit Not used, mainly for geom_smooth purpose
#' @param level Not used, mainly for geom_smooth purpose
#' @param interval Not used, mainly for geom_smooth purpose
#' @export
#'
predict.fitIC50 <- function(object, newdata = NULL, se.fit = FALSE, level = 0.95 , interval = c("none", "confidence", "prediction")) {
if (is.null(newdata))
newdata <- object$model else
newdata <- newdata
params <- object$parm_fit$parameters
a <- min(params[1],params[4])
d <- max(params[4],params[1])
x <- params[2]
b <- params[3]
predY <- function(x) {
y = d + (a-d)/(1+(x/c)^b)
names(y) <- NULL
return(y)
}
if (is.vector(newdata)) {
conc <- newdata
} else if (is.data.frame(newdata)) {
if (ncol(newdata) == 1) {
conc <- newdata[,1]
} else {
concName <- as.character(object$formula)[3]
conc <- newdata[,concName]
}
}
res <- sapply(conc, predY)
return(res)
}
source('~/CLLproject_jlu/packages/DrugScreenExplorer/R/processData.R', echo=TRUE)
aa
ggplot(aa, aes(x=concentration, y = viab)) + geom_smooth(method ="IC50")
ggplot(aa, aes(x=concentration, y = viab)) + geom_smooth(method ="fitIC50")
ggplot(aa, aes(x=concentration, y = viab)) + geom_smooth(method ="fitIC50", se=FALSE)
ggplot(aa, aes(x=concentration, y = viab)) + geom_smooth(method ="fitIC50", se=FALSE)
ggplot(aa, aes(x=concentration, y = viab)) + geom_point() + geom_smooth(method ="fitIC50", se=FALSE)
ggplot(aa, aes(x=concentration, y = viab)) + geom_point() + geom_smooth(method ="fitIC50", se=FALSE) + scale_x_log10()
ggplot(aa, aes(x=concentration, y = viab)) + geom_point()
aa
library(tidyverse)
ggplot(aa, aes(x=concentration, y=viab))
quartz()
ggplot(aa, aes(x=concentration, y=viab))
ggplot(aa, aes(x=concentration, y=viab)) + geom_point()
ggplot(aa, aes(x=concentration, y = viab)) + geom_point() + geom_smooth(method ="fitIC50", se=FALSE)
ggplot(aa, aes(x=concentration, y = viab)) + geom_point() + geom_smooth(method ="fitIC50", se=FALSE) + scale_x_log10()
ggplot(aa, aes(x=concentration, y = viab)) + geom_point() + geom_smooth(method ="fitIC50", se=FALSE)
ggplot(aa, aes(x=concentration, y = viab)) + geom_point() + geom_smooth(method ="fitIC50", se=FALSE, method.args = list(logDose=10))
jyluMisc::fitIC50()
jyluMisc::fitIC50()
jyluMisc::fitIC50
runApp('~/CLLproject_jlu/packages/DrugScreenExplorer/shiny')
