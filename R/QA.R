#Functions for diagnostic plots and quality assessment

#' Plot the layout or measurements on each screening plate
#'
#' This function plot a heatmap or a series of heatmaps showing the plate layout or the measurements on the screening plates
#'
#' @param screenData The tidytable containing screening results generated by readScreen() function
#' @param plotPlate A character string or a vector of character strings specifying the file name of the plates. If all plates should be plotted, "all" can be used. Default value is "all"
#' @param plotType A character string, either "layout", "zscore", "viability" can be used. If "layout" is specified, the plate layout will be plotted in a heatmap according to the information in the "wellType" column. If "zscore" is chosen, the zscore of each well on a plate will be plotted in the heatmaps. If "viability" is used, the viability value on each plate will be plotted. This choise is only valied when the percent inhibition values were calculated when read in the screen data or using the normalizePlate function. Default is "layout"
#' @param ifCorrected A logical string, whether to plot the orignial viablity values or viablity values after edge effect correction. The default value is FALSE, plot the original value.
#' @param limits A numeric vector indicates the lower and upper limits of the value shown in the heatmap. The default values is (0,2) for plotType= "inhibition" and (-3,3) for plotType = "zscore".
#' @param pdfName A character string specifying the output pdf file name. If not specified, a list containing the ggplot objects of plate plots will be returned. Default is NULL.
#' @param ncol The number of columns in a page. Default number is 2.
#' @param nrow The number of rows in a page. Default number is 3.
#' @param width The width of the page
#' @param height The height of the page
#' @import tidyverse ggplot2 gridExtra
#' @export

platePlot <- function(screenData, plotPlate = "all", plotType = "layout", ifCorrected = FALSE,
                      limits = NULL, pdfName = NULL, ncol = 2, nrow = 3,
                      width = 16, height = 16) {

  if (all(plotPlate == "all")) {
    plateList <- unique(screenData$fileName)
  } else {
    plateList <- intersect(unique(screenData$fileName), plotPlate)
  }
  if (length(plateList) == 0) stop("No plate found")

  nCol <- length(unique(screenData$colID))
  nRow <- length(unique(screenData$rowID))
  rowSeq <- genRowIDs(nRow)
  colSeq <- genColIDs(nCol)

  matPlate <- screenData %>%
    mutate(rowID = factor(rowID, levels = rev(rowSeq))) %>%
    mutate(colID = factor(colID, levels = colSeq))

  if (plotType == "layout") {
    plotList <- lapply(plateList,function(plateName){
        p <- filter(matPlate, fileName == plateName) %>%
            ggplot(aes(x = colID, y= rowID, fill = wellType)) +
            geom_tile(color = "grey80") + xlab("") + ylab("") + theme_void() +
            ggtitle(plateName) +
            theme(axis.text = element_text(size=6), axis.ticks = element_blank(),
                  plot.title = element_text(hjust = 0.5),plot.margin = margin(5,5,5,5))
    })
  } else if (plotType == "viability") {

    if (! "normVal" %in% colnames(matPlate)) stop("No relative viability values found, please normalize the plate first")
    if (is.null(limits)) {
      limits <- c(0,2)
    }

    matPlate <- mutate(matPlate, normVal = ifelse(normVal < limits[1], limits[1],
                                          ifelse(normVal > limits[2], limits[2], normVal)))

    if(ifCorrected) {
      if (! "normVal.cor" %in% colnames(matPlate))
        stop("No edge-corrected viability found, please run edge effect correction first") else
          matPlate <- mutate(matPlate, normVal = normVal.cor)
    }

    plotList <- lapply(plateList,function(plateName){
      p <- filter(matPlate, fileName == plateName) %>%
        ggplot(aes(x = colID, y= rowID, fill = normVal)) +
        geom_tile(color = "grey80") +
        labs(x = "", y = "", fill = "viability", title = plateName) + theme_void() +
        theme(axis.text = element_text(size=6), axis.ticks = element_blank(),
              plot.title = element_text(hjust = 0.5),plot.margin = margin(5,5,5,5))
      if (!is.null(limits)) {
        p <- p + scale_fill_gradient2(limits = limits, high = "red", low = "blue", mid = "white", midpoint = 1)
      } else {
        p <- p + scale_fill_gradient2(high = "red", low = "blue", mid = "white", midpoint = 1)
      }
    })
  } else if (plotType == "zscore") {

    #calculate per-plate z-score
    calcZ <- function(x) mutate(x, zscore = (value-mean(value))/sd(value))
    matPlate <- group_by(matPlate, fileName) %>% do(calcZ(.)) %>% ungroup()

    if (is.null(limits)) {
      limits <- c(-3,3)
    }
      matPlate <- mutate(matPlate, zscore = ifelse(zscore < limits[1], limits[1],
                                                    ifelse(zscore > limits[2], limits[2], zscore)))

    plotList <- lapply(plateList,function(plateName){
      p <- filter(matPlate, fileName == plateName) %>%
        ggplot(aes(x = colID, y= rowID, fill = zscore)) +
        geom_tile(color = "grey80") +
        labs(x = "", y = "", fill = "Z score", title = plateName) + theme_void() +
        theme(axis.text = element_text(size=6), axis.ticks = element_blank(),
              plot.title = element_text(hjust = 0.5), plot.margin = margin(5,5,5,5))
      if (!is.null(limits)) {
        p <- p + scale_fill_gradient2(limits = limits, high = "red", low = "blue", mid = "white", midpoint = 0)
      } else {
        p <- p + scale_fill_gradient2(high = "red", low = "blue", mid = "white", midpoint = 0)
      }
    })
  }
  else if (plotType == "edgeEffect") {

    if (! "edgeFactor" %in% colnames(matPlate)) stop("No edge effect information found, please fit edge effect first")
    if (is.null(limits)) {
      limits <- c(0,2)
    }

    matPlate <- mutate(matPlate, normVal = ifelse(normVal < limits[1], limits[1],
                                                  ifelse(normVal > limits[2], limits[2], normVal)))

    plotList <- lapply(plateList,function(plateName){
      p <- filter(matPlate, fileName == plateName) %>%
        ggplot(aes(x = colID, y= rowID, fill = edgeFactor)) +
        geom_tile(color = "grey80") +
        labs(x = "", y = "", fill = "viability", title = plateName) + theme_void() +
        theme(axis.text = element_text(size=6), axis.ticks = element_blank(),
              plot.title = element_text(hjust = 0.5),plot.margin = margin(5,5,5,5))
      if (!is.null(limits)) {
        p <- p + scale_fill_gradient2(limits = limits, high = "red", low = "blue", mid = "white", midpoint = 1)
      } else {
        p <- p + scale_fill_gradient2(high = "red", low = "blue", mid = "white", midpoint = 1)
      }
    })} else stop("Not a valid option for plotType")

  if (is.null(pdfName)) {
    return(plotList)
  } else {
    makepdf(plotList, pdfName, ncol, nrow, width, height)
  }
}

#' Function for ploting the distribution of the raw signal intensity (raw counts) on each plate
#'
#' This function plots the raw signal itensity (raw counts), or log10 transformed intensity on each plate using boxplots.
#'
#' @param screenData screenData The tidytable containing screening results generated by readScreen() function
#' @param topN An integer value or NULL, indicating how many plates should be plotted. If NULL, all the plates are used.
#' @param ifLog10 A logical value, whether to perform log10 transformation on raw data
#' @import tidyverse ggplot2
#' @export
plotRawCount <- function(screenData, topN = NULL, ifLog10 = FALSE) {
  if (!is.null(topN)) {
    allNames <- unique(screenData$fileName)
    plotTab <- filter(screenData, fileName %in% allNames[1:min(length(allNames),topN)])
  } else {
    plotTab <- screenData
  }

  if (ifLog10) {
    plotTab <- mutate(plotTab, value = log10(value))
  }

  plotTab <- mutate(plotTab, fileName = factor(fileName, levels = rev(unique(fileName))))

  g <- ggplot(plotTab, aes(x = fileName, y = value)) + geom_jitter(width = .3, alpha=0.3, color = "grey50") +
    geom_boxplot(fill=NA, color = "royalblue2", outlier.shape = NA) + coord_flip() + theme_bw() +
    xlab("file names") + ylab(ifelse(ifLog10, "log10 (raw counts)","raw counts"))
}


#' Plotting raw signal distribution for each well type
#' A function to plot the raw signal distribution in annotated well types on a single plate.
#'
#' @param screenData The tidytable containing screening results generated by readScreen() function
#' @param plotPlate A character string or a vector of character strings specifying the file name of the plates. If all plates should be plotted, "all" can be used. Default value is "all"
#' @param ifLog10 A logical value, whether to perform log10 transformation on raw data
#' @param pdfName A character string specifying the output pdf file name. If not specified, a list containing the ggplot objects of plate plots will be returned. Default is NULL.
#' @export
#' @import ggplot2 tidyverse gridExtra

plotTypeDist <- function(screenData, plotPlate = "all", ifLog10 = FALSE, pdfName = NULL) {
  if (! "wellType" %in% colnames(screenData)) stop("No well type annotation found")

  if (plotPlate == "all") {
    plateList <- unique(screenData$fileName)
  } else {
    plateList <- intersect(unique(screenData$fileName), plotPlate)
  }
  if (length(plateList) == 0) stop("No plate found")

  pList <- lapply(plateList, function(plateName) {
    plotTab <- filter(screenData, fileName == plateName) %>% mutate(wellType = factor(wellType))
    if (length(unique(plotTab$wellType)) <= 1) stop("The well types on plate is less than 1, nothing to plot")

    if (ifLog10) {
      plotTab <- mutate(plotTab, value = log10(value))
      yLabText <- ylab("log10(raw counts)")
    } else {
      yLabText <- ylab("raw counts")
    }

    ggplot(plotTab, aes(x = wellType, y = value, fill = wellType)) +
      geom_point() + geom_boxplot(alpha = 0.5) + theme_bw() +
      theme(legend.position = "none",
            plot.title = element_text(hjust = 0.5, face = "bold", size=10),
            axis.text.x = element_text(face = "bold", size= 10),
            axis.text.y = element_text(size=10),
            plot.margin = margin(5,5,5,5)) +
      yLabText + xlab("well types") + ggtitle(plateName)
   })
   names(pList) <- plateList

   if (is.null(pdfName)) {
     return(pList)
   } else {
     makepdf(pList, pdfName, ncol = 2, nrow =2, 8, 8)
   }
}

#' Function for estimating edge effect on each plate
#'
#' This function estimates the intensity of edge effect on each screen plate by comparing the median measurment values on the edge and on the inner plate. And plot the edge effect factor distributions among plates.
#'
#' @param screenData The tidytable containing screening results generated by readScreen() function
#' @param nLayer An integer value larger than 1, indicating up to how many layers on the edge of the screen are considered as edges. The default value is 1.
#' @param onlyNeg A logical value, whether only well annotated as negative controls are used for edge effect estimation. If FALSE, all the measurements on each plate are used for edge effect estimation. The functions will automatically check wehther there are negative control wells on the edge or inside the well under the partition of edge wells and inner wells specified by nLayer parameter. Default is TRUE.
#' @param pdfName Either NULL or a character string specifying the output file name for the plot in pdb format. If NULL, no plot will be created.
#' @param identifier A character string specifing the colname in the screenData table that will be used as identifiers in the plot. Default value is fileName. If one identifier matches several plates, the error bar will be shown in the plot.
#' @export
#' @import tidyverse ggplot2

estimateEdgeEffect <- function(screenData, nLayer = 1, onlyNeg = TRUE, identifier = "fileName", pdfName = NULL) {
   estimateOnePlate <- function(plateData, nLayer, onlyNeg) {
     if (nLayer < 1) {
       stop("At least only layer needs to be specified as edge")
     } else {
       nCol <- length(unique(plateData$colID))
       nRow <- length(unique(plateData$rowID))
       edgeCol <- genColIDs(nCol)[c(seq(1,nLayer), seq(nCol-nLayer+1, nCol))]
       edgeRow <- genRowIDs(nRow)[c(seq(1,nLayer), seq(nRow-nLayer+1, nRow))]
     }

     edgeWell <- filter(plateData, colID %in% edgeCol, rowID %in% edgeRow) %>% select(wellID, value, wellType)
     innerWell <- filter(plateData, ! wellID %in% edgeWell$wellID)

     if (onlyNeg) {
       #only use negative control wells, check wether they are present in edge and innel wells
       if (!"neg" %in% edgeWell$wellType) stop("No negative control wells found on the edge.")
       if (!"neg" %in% innerWell$wellType) stop("No negative control wells found on the inner plate")
       edgeFac <- median(edgeWell$value)/median(innerWell$value)
     } else {
       edgeFac <- median(edgeWell$value)/median(innerWell$value)
     }

     edgeFac
   }

   for ( n in seq(nLayer)) {
     varName <- paste0("edgeRatio",n)
     edgeEffects <- group_by(screenData, fileName) %>% do(tibble(!! varName := estimateOnePlate(.,n,onlyNeg))) %>% ungroup()
     screenData <- left_join(screenData, edgeEffects, by = "fileName")
   }

   if (!is.null(file)) {
       #prepare table for plots
       mapCol <- structure(seq(nLayer), names = paste0("edgeRatio", seq(nLayer)))
       plotTab <- rename(screenData, idn = !! identifier) %>% select(idn, names(mapCol)) %>%
        gather(key = "layer", value = "edgeRatio", -idn) %>% mutate(layer = factor(mapCol[layer])) %>%
         group_by(idn, layer) %>% summarise(meanFac = mean(edgeRatio), sdFac = sd(edgeRatio)) %>%
         arrange(desc(meanFac)) %>% ungroup() %>% mutate(idn = factor(idn, levels = unique(idn)))

       #create plot
       p <- ggplot(plotTab, aes(x=idn, y = meanFac, fill = layer)) +
         geom_bar(position = position_dodge(), stat = "identity") + coord_flip() + theme_bw() +
         xlab(identifier) + ylab("edge effect ratio")

       #generate pdf
       pdfHeight <- length(unique(plotTab$idn)) * 0.8
       pdf(file = pdfName, width =10, height = pdfHeight)
       plot(p)
       dev.off()
   }

   screenData
}


#' Fit a 2D surface to describe the edge effect on each plate
#'
#' This function fits a 2D surface using either loess model or 2D sigmod model based on the measurements on each plate to describe the edge effect.
#'
#' @param screenData The tidytable containing screening results generated by readScreen() function
#' @param method A character string specifing the method used for estimating edge effect. Currently two methods are supported: "loess", which uses local regression to estimate edge effect; "sigmoid", a experimental feature, using 2D-sigmoid model to estimate edge effect.
#' @param useNeg A logical value. If TRUE, only negative controls are used to estimate edge effect. Otherwise, all the wells are used for edge effect estimation.
#' @param useLowConcentrations A integer value. In addition to negative controls, sample wells with low concentrations of drugs or other perturbators can be considered as "de facto" negative controlls and included in edge effect estimation. The default value is 0, means no sample wells are used. If the value n >= 1, the n lowest concentrations will be used.
#' @param span A numeric value. The span parameter for loess, which controls the degree of smoothing.
#' @export
#' @import tidyverse

fitEdgeEffect <- function(screenData, method = "loess", useNeg = TRUE, useLowConcentrations = 0, span = 1) {
  #a function to calculate position correction factor for each plate

  #check if data has been normalized
  #find n lowest concentrations
  if (useLowConcentrations > 0 ){
    #identify the lowest concentrations for each drug
    if (! all(c("name", "concentration","wellType") %in% colnames(screenData))) {
      stop("No information of name, concentration and well type found")
    } else {
      nLowest <- function(x, n) {sort(unique(x))[seq(1,n)]}
      lowConcTab <- filter(screenData, wellType == "sample") %>%
        group_by(name) %>% do(tibble(concentration = nLowest(.$concentration,useLowConcentrations))) %>% ungroup()
    }
  }

  #change rowID and colID to numeric values for fitting
  nRow <- length(unique(screenData$rowID))
  row2num <- structure(seq(nRow), names = genRowIDs(nRow))
  screenData <- mutate(screenData, numRowID = row2num[rowID], numColID = as.integer(colID))

  if (method == "loess") {
    screenData <- group_by(screenData, fileName) %>% do(fitOneLoess(., useNeg, useLowConcentrations, lowConcTab, span)) %>% ungroup()
  } else if (method == "sigmoid") {
    screenData <- group_by(screenData, fileName) %>% do(fitOneSigmoid(., useNeg, useLowConcentrations, lowConcTab)) %>% ungroup()
  }

  select(screenData,-numRowID,-numColID)
}

#' Correct edge effect for each screen plate
#'
#' This function subtract the incubation (or edge) effect from the observed signal intensity to retain the true signal intensity. If the incubation effect has already been estimated by fitEdgeEffect() function, the values in the edgeFactor column will be used. Otherwsie, this function will call fitEdgeEffect function to calculate the edge effect.
#'
#'
#' @param screenData The tidytable containing screening results generated by readScreen() function
#' @param method A character string specifing the method used for estimating edge effect. Currently two methods are supported: "loess", which uses local regression to estimate edge effect; "sigmoid", a experimental feature, using 2D-sigmoid model to estimate edge effect.
#' @param useNeg A logical value. If TRUE, only negative controls are used to estimate edge effect. Otherwise, all the wells are used for edge effect estimation.
#' @param useLowConcentrations A integer value. In addition to negative controls, sample wells with low concentrations of drugs or other perturbators can be considered as "de facto" negative controlls and included in edge effect estimation. The default value is 0, means no sample wells are used. If the value n >= 1, the n lowest concentrations will be used.
#' @param span A numeric value. The span parameter for loess, which controls the degree of smoothing.
#' @param correctMethod A character string specifying the method used for subtracting the edge effect. Currently two methods "bliss" and "linear" are supported.
#'
#' @export
#' @import tidyverse
#'
correctEdgeEffect <- function(screenData, estimateMethod = "loess",
                              useNeg = TRUE, useLowConcentrations = 0, span =1,
                              correctMethod = "bliss", exclude = c()) {

  corEdgeLinear <- function(x,m) {
    inTab <- data.frame(normVal = x, edgeFactor = m)
    s <- apply(inTab,1, function(eachRow) {
      if (eachRow[1] < 0) {
        eachRow[1]
      } else if (eachRow[1] >=0 & eachRow[1] <= eachRow[2]) {
        eachRow[1]/eachRow[2]
      } else {
        eachRow[1] + 1 - eachRow[2]
      }
    })
    s
  }

  if (! "edgeFactor" %in% colnames(screenData) ) {
    #edge effect estimation hasn't been performed. Estiamte the edge effect first
    screenData <- fitEdgeEffect(screenData, method = estimateMethod, useNeg = useNeg,
                                useLowConcentrations = useLowConcentrations, span = span)
  }

  if (correctMethod == "bliss") {
    screenData <- mutate(screenData, normVal.cor = ifelse(fileName %in% exclude | sampleID %in% exclude | patientID %in% exclude,
                                                          normVal, normVal/edgeFactor))
    } else if (correctMethod == "linear") {
      screenData <- mutate(screenData, normVal.cor = ifelse(fileName %in% exclude | sampleID %in% exclude | patientID %in% exclude,
                                                            normVal, corEdgeLinear(normVal, edgeFactor)))
      } else stop("Not a valid choice for edge effect correction method")
  screenData
}
