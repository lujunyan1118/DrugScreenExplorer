# Collection of functions for processing of screen data

#' Fit a 2D surface to describe the edge effect on each plate
#'
#' This function fits a 2D surface using either loess model or 2D sigmod model based on the measurements on each plate to describe the edge effect.
#'
#' @param screenData The tidytable containing screening results generated by readScreen() function
#' @param method A character string specifing the method used for estimating edge effect. Currently two methods are supported: "loess", which uses local regression to estimate edge effect; "sigmoid", a experimental feature, using 2D-sigmoid model to estimate edge effect.
#' @param useNeg A logical value. If TRUE, only negative controls are used to estimate edge effect. Otherwise, all the wells are used for edge effect estimation.
#' @param useLowConcentrations A integer value. In addition to negative controls, sample wells with low concentrations of drugs or other perturbators can be considered as "de facto" negative controlls and included in edge effect estimation. The default value is 0, means no sample wells are used. If the value n >= 1, the n lowest concentrations will be used.
#' @param span A numeric value. The span parameter for loess, which controls the degree of smoothing.
#' @param exclude A list of samples that should be excluded when performing edge effect correction. Both plate file names or sampleIDs can be used as identifiers.
#' @export
#' @import tidyverse

fitEdgeEffect <- function(screenData, method = "loess", useNeg = TRUE, useLowConcentrations = 0, span =1,
                          exclude = c()) {
  #a function to calculate position correction factor for each plate

  # remove precalculated edge factor if present
  if("edgeFactor" %in% colnames(screenData)) screenData[["edgeFactor"]] <- NULL

  #check if data has been normalized
  #find n lowest concentrations
  if (useLowConcentrations > 0 ){
    #identify the lowest concentrations for each drug
    if (! all(c("name", "concentration","wellType") %in% colnames(screenData))) {
      stop("No information of name, concentration and well type found")
    } else {
      nLowest <- function(x, n) {sort(unique(x))[seq(1,n)]}
      lowConcTab <- filter(screenData, wellType == "sample") %>%
        group_by(name) %>% do(tibble(concentration = nLowest(.$concentration,useLowConcentrations))) %>% ungroup()
    }
  }

  #change rowID and colID to numeric values for fitting
  nRow <- length(unique(screenData$rowID))
  row2num <- structure(seq(nRow), names = genRowIDs(nRow))
  screenSub <- mutate(screenData, numRowID = row2num[rowID], numColID = as.integer(colID)) %>%
    filter(!fileName %in% exclude)

  if (method == "loess") {
    screenSub <- group_by(screenSub, fileName) %>%
      do(fitOneLoess(., useNeg, useLowConcentrations, lowConcTab, span)) %>%
      ungroup() %>% select(fileName, rowID, colID, edgeFactor)
  } else if (method == "sigmoid") {
    screenSub <- group_by(screenSub, fileName) %>%
      do(fitOneSigmoid(., useNeg, useLowConcentrations, lowConcTab)) %>%
      ungroup() %>% select(fileName, rowID, colID, edgeFactor)
  }

  screenData <- left_join(screenData, screenSub, by =c("fileName","rowID","colID")) %>%
    mutate(edgeFactor = ifelse(is.na(edgeFactor),1,edgeFactor))

  return(screenData)

}

#' Correct edge effect for each screen plate
#'
#' This function subtract the incubation (or edge) effect from the observed signal intensity to retain the true signal intensity. If the incubation effect has already been estimated by fitEdgeEffect() function, the values in the edgeFactor column will be used. Otherwsie, this function will call fitEdgeEffect function to calculate the edge effect.
#'
#'
#' @param screenData The tidytable containing screening results generated by readScreen() function
#' @param method A character string specifing the method used for estimating edge effect. Currently two methods are supported: "loess", which uses local regression to estimate edge effect; "sigmoid", a experimental feature, using 2D-sigmoid model to estimate edge effect.
#' @param useNeg A logical value. If TRUE, only negative controls are used to estimate edge effect. Otherwise, all the wells are used for edge effect estimation.
#' @param useLowConcentrations A integer value. In addition to negative controls, sample wells with low concentrations of drugs or other perturbators can be considered as "de facto" negative controlls and included in edge effect estimation. The default value is 0, means no sample wells are used. If the value n >= 1, the n lowest concentrations will be used.
#' @param span A numeric value. The span parameter for loess, which controls the degree of smoothing.
#' @param correctMethod A character string specifying the method used for subtracting the edge effect. Currently two methods "bliss" and "linear" are supported.
#' @param exclude A list of samples that should be excluded when performing edge effect correction.
#' @export
#' @import tidyverse
#'
correctEdgeEffect <- function(screenData, estimateMethod = "loess",
                              useNeg = TRUE, useLowConcentrations = 0, span =1,
                              correctMethod = "bliss", exclude = c()) {

  corEdgeLinear <- function(x,m) {
    inTab <- data.frame(normVal = x, edgeFactor = m)
    s <- apply(inTab,1, function(eachRow) {
      if (eachRow[1] < 0) {
        eachRow[1]
      } else if (eachRow[1] >=0 & eachRow[1] <= eachRow[2]) {
        eachRow[1]/eachRow[2]
      } else {
        eachRow[1] + 1 - eachRow[2]
      }
    })
    s
  }

  if ("sampleID" %in% colnames(screenData)) {
    exclude <- c(exclude, filter(screenData, sampleID %in% exclude)$fileName)
  }

  if (! "edgeFactor" %in% colnames(screenData) ) {
    #edge effect estimation hasn't been performed. Estiamte the edge effect first
    screenData <- fitEdgeEffect(screenData, method = estimateMethod, useNeg = useNeg,
                                useLowConcentrations = useLowConcentrations, span = span, exclude = exclude)
  }

  if (correctMethod == "bliss") {
    screenData <- mutate(screenData, normVal.cor =  normVal/edgeFactor)
  } else if (correctMethod == "linear") {
    screenData <- mutate(screenData, normVal.cor = corEdgeLinear(normVal, edgeFactor))

  } else stop("Not a valid choice for edge effect correction method")

  return(screenData)
}


#' Summarise the drug effect across concentrations
#'
#' This function summarises the normalized drug effect (viability) across multiple concentrations into a single value. The summarisation will be based on normalized viability values, so plate normalisation needs to be performed first. If the edge effect corrected viabiliy values are present, the normalisation will be performed on both uncorrected and corrected viabilities. A suffix, ".cor" will be added to the name of summarised values.
#'
#'
#' @param screenData The tidytable containing screening results generated by readScreen() function
#' @param method A character string specifing the method used for summarising the effect. Currently three methods are supported: average, which simply calculates the mean effect under all concentrations; AUC, which calculates the normalized area under dose-reponse curve using linear-log trapezoidal method; IC50, which fits a robust four parameter log-logistic model using dr4pl package.
#' @export
#' @import dr4pl
#'


summariseScreen <- function(screenData, method = "average") {
  #firstly check if necessary columns are presented
  if (! all(c("name", "concentration","sampleID") %in% colnames(screenData))) {
    stop("No information of name, concentration or sampleID found")
  }

  if (! "normVal" %in% colnames(screenData)) {
    stop("Column 'normVal' not found. Plate normalization should be performed first")
  }
  ifCor <- "normVal.cor" %in% colnames(screenData)

  #only summarise for non-control wells
  subData <- screenData[screenData$wellType %in% "sample",]

  if (ifCor) {
    subData <- group_by(subData, sampleID, name, concentration) %>%
      summarise(viab = mean(normVal,na.rm = TRUE), viab.cor = mean(normVal.cor, na.rm=TRUE))
  } else {
    subData <- group_by(subData, sampleID, name, concentration) %>%
      summarise(viab = mean(normVal,na.rm = TRUE))
  }

  if ("average" %in% method) {
    if (ifCor) {
      sumTab <- group_by(subData, sampleID, name) %>%
        summarise(meanViab = mean(viab, na.rm=TRUE),
                  meanViab.cor = mean(viab.cor))
    } else {
      sumTab <- group_by(subData, sampleID, name) %>%
        summarise(meanViab = mean(viab, na.rm=TRUE))
    }

    if ("meanViab" %in% colnames(screenData)) screenData[["meanViab"]] <- NULL
    screenData <- left_join(screenData, sumTab, by= c("sampleID","name"))
  }

  if ("AUC" %in% method) {
    if (ifCor) {
      sumTab <- group_by(subData, sampleID, name) %>%
        summarize(AUC = calcAUC(viab,concentration), AUC.cor = calcAUC(viab.cor,concentration))
    } else {
      sumTab <- group_by(subData, sampleID, name) %>%
        summarize(AUC = calcAUC(viab,concentration))
    }
    if ("AUC" %in% colnames(screenData)) screenData[["AUC"]] <- NULL
    screenData <- left_join(screenData, sumTab, by = c("sampleID","name"))
  }

  if ("IC50" %in% method) {

    sumTab <- group_by(subData, sampleID, name) %>%
      nest() %>%
      mutate(model = map(data, ~sumIC50(viab~concentration,.))) %>%
      unnest("model")
    sumTab$data <- NULL

    if (ifCor) {
      sumTab.cor <- group_by(subData, sampleID, name) %>%
        nest() %>%
        mutate(model = map(data, ~sumIC50(viab.cor~concentration,.))) %>%
        unnest("model")
      sumTab.cor$data <- NULL
      newColName <- colnames(sumTab.cor)
      newColName[!newColName %in% c("sampleID","name")] <- paste0(newColName[!newColName %in% c("sampleID","name")],".cor")
      colnames(sumTab.cor) <- newColName
      sumTab <- left_join(sumTab, sumTab.cor, by =c("sampleID","name"))
    }

    for (colN in c("UpperLimit","IC50","Slope","LowerLimit")) {
      if (colN %in% colnames(screenData)) screenData[[colN]] <- NULL
    }
    screenData <- left_join(screenData, sumTab, by = c("sampleID","name"))
  }

  return(screenData)

}


# Model object for fitting 4 parameter logistic (4PL) models. (Used for ggplot smooth function)
#'
#' Use the dr4pl package to perform IC50 fit. Can be directly used for geom_smooth() in ggplot2
#' @param formula Formula for the curve fitting.
#' @param data A data frame contain the raw concentration and the viability value. The viability should not be the percent viability value.
#' @param weigths Not used, mainly for geom_smooth() purpose
#' @param ... Parameters passed to logLogisticRegression()
#' @export
#' @import dr4pl

fitIC50 <- function(formula, data = NULL, weights = NULL, logDose = NULL, ...) {
  if (! is.null(data) ) {
    modelFrame <- model.frame(formula, data)
  } else {
    modelFrame <- model.frame(formula)
  }

  if (!is.null(logDose)) {
    modelFrame[,2] <- logDose^modelFrame[,2]
  }

  parm_fit <- dr4pl(modelFrame[,2],modelFrame[,1])
  newModel <- list(model = modelFrame, formula = formula, parm_fit = parm_fit, logDose = logDose)

  class(newModel) <- "fitIC50"
  return(newModel)
}

#' Predicted values based on IC50 fit
#'
#' Generic function for IC50 class generated from fitIC50 function.
#' @param object Object of class inheriting from "fitIC50"
#' @param newdata An optional data frame in which to look for variables with which to predict. If omitted, the fitted values are used.
#' @param se.fit Not used, mainly for geom_smooth purpose
#' @param level Not used, mainly for geom_smooth purpose
#' @param interval Not used, mainly for geom_smooth purpose
#' @export
#'
predict.fitIC50 <- function(object, newdata = NULL, se.fit = FALSE, level = 0.95 ,
                            interval = c("none", "confidence", "prediction"), ...) {

  if (is.null(newdata))
    newdata <- object$model else
      newdata <- newdata

    params <- object$parm_fit$parameters
    logDose <- object$logDose

    a <- min(params[1],params[4])
    d <- max(params[4],params[1])
    c <- params[2]
    b <- params[3]

    predY <- function(x) {
      y = d + (a-d)/(1+(x/c)^b)
      names(y) <- NULL
      return(y)
    }

    if (is.vector(newdata)) {
      conc <- newdata
    } else if (is.data.frame(newdata)) {
      if (ncol(newdata) == 1) {
        conc <- newdata[,1]
      } else {
        concName <- as.character(object$formula)[3]
        conc <- newdata[,concName]
      }
    }

    if (!is.null(logDose)) conc <- logDose^conc
    res <- sapply(conc, predY)

    return(res)
}

