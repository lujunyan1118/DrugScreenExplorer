#' Generate Rmarkdown report
#'
#' A function to generate customized html Rmarkdown report for quality assessment
#' @param screenData The tidytable containing screening results generated by readScreen() function.
#' @param showCode Boolean value, whether to show code in the html.
#' @param title Character string specifying the title for the html report
#' @param author Character string specifying the author name
#' @param ifPlatePlot Boolean value, whether to make plate plots in the report. Plate plots for large screens are time consuming.
#' @export
#' @import rmarkdown
makeReport <- function(screenData, showCode = FALSE,
                       title = "Report for my drug screening project", author = "John Smith",
                       ifPlatePlot = FALSE) {

  #create a directoy for report
  dir.create("./report", showWarnings = FALSE)
  dir.create("./report/plots", showWarnings = FALSE)

  #save the screenData object to a file
  saveRDS(screenData, file = "report/screenData.rds", compress = TRUE)

  #template file
  tempRmd <- system.file("template.Rmd", package = "DrugScreenExplorer")
  file.copy(tempRmd, "./report/report.Rmd", overwrite = TRUE)
  #render html with parameters

  rmarkdown::render(input = "./report/report.Rmd", output_file = "report.html",
                    params = list(showCode = showCode,
                                  set_title = title,
                                  set_author = author,
                                  ifPlatePlot = ifPlatePlot),
                    quiet = TRUE)
}


#' Generate interactive shiny app
#' A funtion to generate customized shiny app for interactive exploration of the screen data
#'
#' @param screenData The tidytable containing screening results generated by readScreen() function
#' @param sampleAnnotations A vector of character strings, specifying the columns that should be used as sample annotations.
#' @export
#' @import Rtsne pheatmap broom shiny plotly DT RColorBrewer dr4pl


makeShiny <- function(screenData, sampleAnnotations = c("sampleID", "patientID")) {
  dir.create("./shiny", showWarnings = FALSE)
  # add file name column
  if (! "fileName" %in% sampleAnnotations) sampleAnnotations <- c(sampleAnnotations,"fileName")

  #check if sample annotations are in the data
  notFound <- sampleAnnotations[! sampleAnnotations %in% colnames(screenData)]
  if (length(notFound != 0)){
    stop(paste0(paste0(notFound, collapse = ",")," not found in the column names of the screen data"))
  }

  #change character values to factors, for filtering
  screenData <- mutate_if(screenData, is.character, as.factor)

  #change batch to factor
  if ("batch" %in% colnames(screenData)) {
    screenData <- mutate(screenData, batch = as.factor(batch))
  } else screenData <- mutate(screenData, batch = as.factor(0))

  #calculate AUC using linear-log trapezoidal method
  if ("normVal" %in% colnames(screenData) & ! "meanViab" %in% colnames(screenData)) {
   summariseScreen(screenData, method = "average")
  }


  #remove group
  screenData <- ungroup(screenData)

  save(screenData, sampleAnnotations, file = "./shiny/shinyData.RData")
}

#' Detect data type, used for shiny app
#' A funtion to detect wether a vector is numeric, binary or catagorical.
#'
#' @param x A vector of input data
#' @export

detectClass <- function(x) {
  #change potential NA records to NA
  x[x %in% c("","NA")] <- NA
  x <- na.omit(x)
  nx <- length(unique(x))

  if (nx <= 1) {
    return("nd")
  } else if (nx == 2) {
    return("binary")
  } else {
    x.num <- as.numeric(as.character(x))
    if (all(!is.na(x.num))) {
      return("continuous")
    } else {
      if (nx < length(x)) {
        return("categorical")
      } else return("nd")
    }
  }
}
